// Initialize instruction cards
const instructionCards = [
    { desc: 'add', syntax: 'add a, [k]', originalSyntax: 'ad k', operations: 'a < a + M[k]', cycles: 2 },
    { desc: 'load', syntax: 'ld a, [k]', originalSyntax: 'ca k', operations: 'a < M[k]', cycles: 2 },
    { desc: 'store', syntax: 'ld [k], a', originalSyntax: 'AD k', operations: 'a < a + M[k]', cycles: 2 },
    { desc: 'Exchange', syntax: 'xchg a [k]', originalSyntax: 'xch k', operations: 'M[k] <> A', cycles: 2 },
    { desc: 'subtract', syntax: 'sub a, [k]', originalSyntax: 'SU k', operations: 'A < A - M[k]', cycles: 3 },
    { desc: 'LOAD cpl', syntax: 'ldc a, [k]', originalSyntax: 'cs k', operations: 'a < -M[k]', cycles: 2 },
    { desc: 'increment', syntax: 'inc [k]', originalSyntax: 'INCR k', operations: 'M[k] < M[k]+1', cycles: 2 },
    { desc: 'Augment', syntax: 'aug [k]', originalSyntax: 'AUG k', operations: 'if M[k]>=0: M[k]<M[k]+1 if M[j]<=-0: m[k] <M[k]-1', cycles: 3 },
    { desc: 'Diminish', syntax: 'dim [k]', originalSyntax: 'DIM k', operations: 'if M[k]>+0: M[k]<M[k]-1 if M[j]<-0: m[k] <M[k]+1', cycles: 3 },
    { desc: 'Multiply', syntax: 'mul [k]', originalSyntax: 'mp k', operations: 'a, b < A * m[k]', cycles: 4 },
    { desc: 'Divide', syntax: 'div [k]', originalSyntax: 'dv k', operations: 'A < a,b / M[k]  B< a,b % m[k]', cycles: 7 },
    { desc: 'Load double', syntax: 'ld ab, [k]', originalSyntax: 'DCA k', operations: 'a<M[k] B<M[k+1]', cycles: 4 },
    { desc: 'Load dbl cpl', syntax: 'ldc ab, [k]', originalSyntax: 'DCS k', operations: 'a< -M[k] B< -M[k+1]', cycles: 4 },
    { desc: 'Xchg double', syntax: 'xchg ab,[k]', originalSyntax: 'DXCH k', operations: 'a <> M[k]  b <> M[k+1]', cycles: 3 },
    { desc: 'Add Double', syntax: 'add [k], ab', originalSyntax: 'DAS k', operations: 'M[k,k+1] < M[k,k+1] + a,b', cycles: 3 },
    { desc: 'Exchange B', syntax: 'xchg b [k]', originalSyntax: 'lxch k', operations: 'M[k] <> B', cycles: 2 },
    { desc: 'JUMP', syntax: 'jmp k', originalSyntax: 'tfc k', operations: 'PC < k', cycles: 1 },
    { desc: 'JUMP = 0', syntax: 'jz k', originalSyntax: 'bzf k', operations: 'if a =+/-0: pc<k', cycles: 2 },
    { desc: 'JUMP <= 0', syntax: 'jlez k', originalSyntax: 'bzmf k', operations: 'if a <=+/-0: pc<k', cycles: 2 },
    { desc: 'count, compare and skip', syntax: 'ccs [k]', originalSyntax: 'ccs k', operations: 'a < DABS(M[k]) if M[k]>+0: pc < pc  if M[k]=+0: pc<pc+1 if M[k]<-0: pc < pc+2  if m[k] =-0: pc <pc+3', cycles: 2 },
    { desc: 'call', syntax: 'call k', originalSyntax: 'tc k', operations: 'lr < pc | pc < k', cycles: 1 },
    { desc: 'return', syntax: 'ret', originalSyntax: 'return', operations: 'lr < pc | pc < 2', cycles: 1 },
    { desc: 'Exchange LR', syntax: 'xchg lr [k]', originalSyntax: 'qxch k', operations: 'LR <> M[k]', cycles: 3 },
    { desc: 'Call far', syntax: 'callf', originalSyntax: 'dtcf', operations: 'a <> FB   b<>PC', cycles: 3 },
    { desc: 'Return far', syntax: 'retf', originalSyntax: 'dtcf', operations: 'a <> FB   b<>PC', cycles: 3 },
    { desc: 'Call far both banks', syntax: 'callfbb', originalSyntax: 'dtcb', operations: 'a<>pc  b <> BB', cycles: 3 },
    { desc: 'return far both banks', syntax: 'retfbb', originalSyntax: 'dtcb', operations: 'a<>pc  b <> BB', cycles: 3 },
    { desc: 'in', syntax: 'in a, [kc]', originalSyntax: 'read kc', operations: 'a < IO[kc]', cycles: 3 },
    { desc: 'out', syntax: 'out[kc], a', originalSyntax: 'write kc', operations: 'IO[kc] <a', cycles: 3 }
];